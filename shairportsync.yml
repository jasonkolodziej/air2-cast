--- 
GENERATOR: 
  #? Specifies the package name for the generated code. 
  #? A directory with that name will be created in the -out prefix (. by default) provided for the c-for-go executable.
  PackageName: shairportsync
  # * mac:
  #*   Build: autoconf ✘, automake ✘, pkg-config ✘
  #*   Required: libao ✘, libconfig ✘, libdaemon ✘, libsoxr ✘, openssl@3 ✔, popt ✘, pulseaudio ✘
  #? Specifies the package description that will be written into doc.go and act as a short description in GoDoc.
  PackageDescription: "Package vorbis provides Go bindings for OggVorbis implementation by the Xiph.Org Foundation"
  #? Specify a license for the generated code. I prefer delegating all the rights to the robots.
  PackageLicense: "THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS."
  #? This section allows to specify controversial options to be enabled within the generator. Currently available options:
  # Options:
  #? An optional parameter that leverages pkg-config if the library you are binding have any .pc manifests. 
  #? Firstly, the parser module will be configured by c-for-go main routine to use the specified include search paths, 
  #? it does so by parsing *.pc files with github.com/xlab/pkgconfig/pkg. 
  #? Secondly, the generator will write a CGo header that the Go toolchain respects, 
  #? so at compiling and linking stages it will find all required include files and shared objects.
  PkgConfigOpts: [popt, libconfig, soxr]

  #? The list of include files that generator must write in the resulting files so CGo will find all the symbols used.
  Includes: 
  #* #include "ogg/ogg.h"
  #* #include "vorbis/codec.h"

    # - "ogg/ogg.h"
    # - "vorbis/codec.h"
    # - "vorbis/vorbisenc.h"
    - "rtp.h"
    - "common.h"

  #? These files (apart of `Includes:`) are part of the distribution so the paths are relative. 
  #? Consider SysIncludes if you're expecting the system to have these headers. 
  #? Be aware that system headers and the generated bindings must be compatible, any missing declarations will fail the build.
  # SysIncludes:
  #* #include <ogg/ogg.h>
  #* #include <vorbis/codec.h>

    # -
  #? This option allows to specify flag groups with build constraints for CGo, the group is represented as:
  #? https://github.com/xlab/c-for-go/wiki/Generator-config-section#flaggroups
  #? A common example would be specifying a platform-dependent LDFLAGS or CFLAGS group, the traits are specified as described in Build Constraints.
  # FlagGroups:
    #* - {name: "CFLAGS", traits: ["linux"], flags: [-DMDB_USE_SYSV_SEM=1]}
    #* - {name: "LDFLAGS", traits: ["windows"], flags: [-lntdll]}
    
    # -
#? Most of these options are going directly as configuration parameters for cznic/cc.
PARSER: 
  #? Specifies a list of paths where to search all the referenced include files while parsing C header files. 
  #? This goes straight to cznic/cc and does not correlate nor with system environment nor the Go toolchain.
  IncludePaths:
    - "/usr/include"
    - "shairportsync/internal"
    - "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include"
  #? Specifies a list of C header files to parse. 
  #? These are usually relative to the c-for-go working directory (.) or 
  #? absolute on the system of the developer who maintains the bindings.
  SourcesPaths: 
    # - "vorbis/ogg/ogg.h"
    # - "vorbis/vorbis/codec.h"
    # - "vorbis/vorbis/vorbisenc.h"
    - "shairportsync/internal/rtp.h"
    - "shairportsync/internal/common.h"
    - "shairportsync/internal/definitions.h"
    - "shairportsync/internal/player.h"
    - "shairportsync/internal/alac.h"
    - "shairportsync/internal/loudness.h"
    - "shairportsync/internal/dacp.h"
    - "shairportsync/internal/activity_monitor.h"
    - "shairportsync/internal/ptp-utilities.h"
  #? Override the target CPU architecture. Defaults to `x86_64` but supported bases are:
  # Arch:
  #*   i386, x86_48, x86_64, arm, aarch64
    # -
  #? Allows user to specify custom defines, override built-in ones and disable dubious macros.
  Defines:
    #* __STDC_HOSTED__: null
    #* VK_USE_PLATFORM_ANDROID_KHR: yes
    #* VK_NO_PROTOTYPES: 1
    #* __dafuq__: {}
    CONFIG_AIRPLAY_2: 1

TRANSLATOR:
  #? These boolean flags have been added recently to explicitly turn off `const char *` (also `const unsigned char *`) as string in Go, 
  #? thus asserting its immutability. The problem of such translation was in treating `\x00` within the data passed to Go land. 
  #? With string being asserted, data could be trimmed too early. So for some projects ConstCharIsString and ConstUCharIsString 
  #? allow to disable that heuristic rule and treat `const char *` as `char *` i.e. `[]byte`.
  #? ConstCharIsString is set to true by default, ConstUCharIsString is set to false by default.
  ConstCharIsString: true
  ConstUCharIsString: false
  #? Specifies the rules of constant value unfolding. 
  #? There are two const scopes: `enum` and `defines`, 
  #?  so they are used to match the origin of value, whether it has been defined in `#define` or 
  #?  has been declared as enumeration.
  #? SEE more: https://github.com/xlab/c-for-go/wiki/Translator-config-section#construles
  ConstRules:
  #* There are three unfold rules: `eval`, `cgo` and `expand`. By default `eval` is being used by translator. 
    defines: eval
    # enum: cgo
  #? Rules are the translator's main engine, this part makes all the difference between c-for-go and SWIG. 
  #? In general, this section defines a set of rules for each target scope, 
  #? the scopes correspond to processing stages when rules are being taken into account, 
  #? the names of entities being processed are matched agains regular expressions and the specified actions are 
  #? being executed for that entity. Now let's talk more specific.    
  Rules:
  #* There are several rule scope groups: (`global`, `post-global`), (`const`, `type`, `function`), (`public`, `private`).
    #? sets actions and accept/reject rules that take precedence before specific type scopes;
    global: 
      - {transform: lower}
        #? Action: accept/reject
        #? These are simple rules whose from field specifies a regular expression the original 
        #? C name should match and an action to take when one does match. 
        #? Every name is checked against each expression until it's clear whether we should accept or ignore the name. 
        #? By default everything is ignored.
      # - {action: accept, from: "^vorbis_"}
      # - {action: accept, from: "^ogg_"}
      #   #? Action: replace
      #   #? Rules with action replace are forming the replace/transform pipeline. 
      #   #? These rules are being applied in order of occurrence and are capable of substring transformation. 
      #   #? Having from filled but to empty means making a cut out.
      # - {action: replace, from: "^vorbis_", to: _}
        #? Transform:
        #? In order to keep rules as simple as possible, 
        #? there is a set of predefined transforms that are commonly used in name normalization.
      - {transform: export}
    #? sets rules that are considered at last;
    post-global: 
        #? Action: doc
        #? The special action doc allows to define the documentation source. 
        #? By default that is the position in the originating C header file, but this may be overridden. 
        #? The from filter allows to narrow the scope of the target entities and to specifier defines a template. 
        #? Supported template variables: `path`, `file`, `line`, `name`, `goname`. 
        #? The latter two represent C entity name and Go entity name (after transforms). The default template is `$path:$line`.
      # - {action: doc, from: "^ogg_u?int[0-9]+_t"} # types like ogg_uint32_t
      # - {action: doc, from: "^ogg_", to: "https://xiph.org/ogg/doc/libogg/$name.html"}
      # - {action: doc, from: "^vorbis_", to: "https://xiph.org/vorbis/doc/libvorbis/$name.html"}
      - {action: replace, from: _$}
      - {load: snakecase}
    #? sets rules that being applied depending on the visibility of entity, 
    #? e.g. function args are considered private since they cannot be referenced;
    # public:
    #? sets rules that being applied depending on the visibility of entity, 
    #? e.g. function args are considered private since they cannot be referenced;
    private:
      - {transform: unexport}
    #? target the specific groups of entities.
    const:
      - {action: accept, from: "^OV_"}
      - {action: replace, from: "^ov_", to: _}
    #? target the specific groups of entities.
    type: 
      - {action: replace, from: "_t$"}
    # function:
    #   - {target: "vorbis_analysis_headerout$", tips: [sref,sref,sref,sref,sref]}
    #   - {target: "vorbis_synthesis_pcmout$", tips: [ref,arr]}
    #   - {target: ^vorbis_, tips: [ref,ref,ref]}
    #   - {target: ^ogg_, self: arr, tips: [ref,ref]}
  #? Specifies the translation tips for pointer types. 
  #? There are three possible tips: `ref`, `sref` and `arr`. 
  #? If your type in C looks like `int *`, then using `ref` tip against it will leave `*int32` in Go,
  #? using arr will yield `[]int32 `and will use special conversion options (`unpack`/`pack`) to pass that 
  #? through in both directions. The `sref` option is a special one for multiple pointer cases in C, 
  #? when you are expected to provide a pointer to a pointer, etc.
  #? Ref: https://github.com/xlab/c-for-go/wiki/Translator-config-section#ptrtips
  # PtrTips:
  # #* Supported scopes: `function`, `struct`, `any`. A pointer tip can be targeted to `function` args, 
  # #* to `function` return value, to `struct` fields, to any name matching pattern.
  #   function:
  #       #? Where target is any supported regular expression. `Self` tip targets the function return value. 
  #       #? Default tip for missing cases, however I advise to fill all tips, default ones mark as `0` or `size`. 
  #       #? The latter does nothing because it's not a valid tip, but it helps to maintain these tips and avoiding human errors.
  #     - {target: "vorbis_analysis_headerout$", tips: [sref,sref,sref,sref,sref]}
  #     - {target: "vorbis_synthesis_pcmout$", tips: [ref,arr]}
  #     - {target: ^vorbis_, tips: [ref,ref,ref]}
  #     - {target: ^ogg_, self: arr, tips: [ref,ref]}
  #? Specifies the translation tips that can help to distinguish between 
  #? `UODawgSpecial32` and `float32` plain type that might be the same in terms of memory 
  #? and only a developer may know that. Especially useful in cases when there are deeply nested `typedefs`, 
  #? to the base plain type is not so easy to exact automatically. Similar to `PtrTips` and the `tip` spec is the same, 
  #? the only allowed tips are `named` and `plain` respectively. By default all types are considered as `named`.
  # TypeTips:
      #* function:
      #* - {target: ^glBindAttribLocation$, tips: [0,0,plain]}
      #* - {target: ^glGetAttribLocation$, tips: [0,plain]}
      #* - {target: ^glGetUniformLocation$, tips: [0,plain]}
      #* - {target: ^glGetProgramInfoLog$, tips: [0,0,0,plain]}
      #* - {target: ^glShaderSource$, tips: [0,0,plain,0]}
      #* - {target: ^glGetString$, self: plain}
  #? Specifies the translation tips regarding the handling of `struct` memory and fields. 
  #? Similar to `PtrTips` and the `tip` spec is the same, but the difference is that it does not target any scope, 
  #? it's just a list that turns off any `struct` introspection of C types, 
  #? thus avoiding `unsafe` conversions and disables bindings generation for a `type` or a field. 
  #? Possible tips: `raw`.
  #? ref: https://github.com/xlab/c-for-go/wiki/Translator-config-section#memtips
  # MemTips:
  #*   - {target: VkAllocationCallbacks, self: raw}
  #*   - {target: ANativeWindow, self: raw}